# Websocket

@@@ note { title=Prerequisites }

This page assumes you have checked out a local copy of [estimate.poker](https://github.com/KyleU/estimate) and switched to the `08-scala-js` branch

@@@


## Websocket Library

Edit `Server.scala`, and change it to depend on @ref[`projectile-lib-websocket`](../../libraries/websocket.md):

`project/Dependencies.scala`:

```scala
val all = Seq("websocket", "slick").map(s => "com.kyleu" %% s"projectile-lib-$s" % version)
```


## Network messages

Like most real-time web applications, we'll be using a websocket, passing JSON or binary serialized data bi-directionally. 
These files contain our message definitions. They'll grow as we add more functionality

- [`shared/src/main/scala/models/message/ClientMessage.scala`](https://github.com/KyleU/estimate/blob/09-websocket/shared/src/main/scala/models/message/ClientMessage.scala)
- [`shared/src/main/scala/models/message/ServerMessage.scala`](https://github.com/KyleU/estimate/blob/09-websocket/shared/src/main/scala/models/message/ServerMessage.scala)


## Participant models

We need each unique visitor to have an identifier, so we use the files that were generated by Projectile for the `participant` table.
This file generates a participant based on an http request

- [`app/util/web/ParticipantHelper.scala`](https://github.com/KyleU/estimate/blob/09-websocket/app/util/web/ParticipantHelper.scala)


## Actor service

Out clients need to connect to something, so this file extends [`ConnectionService`](https://github.com/KyleU/projectile/blob/master/libraries/projectile-lib-websocket/app/com/kyleu/projectile/services/connection/ConnectionService.scala) and handles the messages we defined earlier

- [`app/services/session/actor/ParticipantConnectionService.scala`](https://github.com/KyleU/estimate/blob/09-websocket/app/services/session/actor/ParticipantConnectionService.scala)

We also need to wire up an actor supervisor, so add the following lines to `ProjectileModule.scala`:

```scala
@Provides @javax.inject.Singleton @Named("connection-supervisor")
def provideConnectionSupervisor(actorSystem: ActorSystem): ActorRef = {
  actorSystem.actorOf(ConnectionSupervisor.props(err = WebsocketController.errJson), "connections")
}
```

## Scala.js connection

We need a client-side websocket connection, so we'll make `ConnectionService`, and a JS entrypoint

- [`client/src/main/scala/ConnectionService.scala`](https://github.com/KyleU/estimate/blob/09-websocket/client/src/main/scala/ConnectionService.scala)
- [`client/src/main/scala/Entrypoint.scala`](https://github.com/KyleU/estimate/blob/09-websocket/client/src/main/scala/Entrypoint.scala)


## Controllers, routes, and views

Let's add a controller that defines a new `/test` action and extends `WebsocketController` to connect with our service.

- [`app/controllers/ConnectionController.scala`](https://github.com/KyleU/estimate/blob/09-websocket/app/controllers/ConnectionController.scala)

Now we need a view for our new action, so here it is. Note that it includes our ScalaJS project `client`.

- [`app/views/connect.scala.html`](https://github.com/KyleU/estimate/blob/09-websocket/app/views/connect.scala.html)

And finally, we'll add new `routes` for our new actions:

```
GET         /test                                    controllers.ConnectionController.test()
GET         /connect                                 controllers.ConnectionController.connect(binary: Boolean ?= false)
```


## Putting it all together

If you followed along (or just checked out this branch), you should have a working application the connects via a websocket and sends pings every few seconds. Exciting!

http://localhost:24000/test


## Explore the code

https://github.com/KyleU/estimate/tree/09-websocket

See this branch's Pull Request for detailed comments on the generated files

https://github.com/KyleU/estimate/pull/9


## Next steps

Ok, we're all wired up - let's finish this thing and @ref[build a real app](10-planning-poker.md)!
