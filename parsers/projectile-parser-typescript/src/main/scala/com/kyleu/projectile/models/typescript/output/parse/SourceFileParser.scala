package com.kyleu.projectile.models.typescript.output.parse

import better.files.File
import com.kyleu.projectile.models.output.OutputPath
import com.kyleu.projectile.models.output.file.MarkdownFile
import com.kyleu.projectile.models.typescript.node.SourceFileHeader
import com.kyleu.projectile.models.typescript.node.TypeScriptNode.SourceFile

object SourceFileParser {
  def forSourceFiles(ctx: ParseContext, nodes: Seq[SourceFile]) = {
    val file = MarkdownFile(OutputPath.SharedSource, ctx.pkg, "index")
    val header = nodes.foldLeft(SourceFileHeader())((l, r) => l.merge(r.header))

    file.add()

    val nameLink = header.projectName.map(n => header.projectUrl match {
      case Some(url) => s"[$n]($url)"
      case None => n
    }).map(_ + " ").getOrElse("")

    file.add(s"# ${nameLink}Scala.js facade")
    file.add()

    file.add("## Generated code")
    file.add()
    file.add(s"The contents of this package were generated by [Projectile](https://kyleu.com/projectile)")

    file.add()
    nodes.foreach(node => file.add(s"  - ${ctx.root.relativize(File(node.path)).toString}"))

    if (header.authors.nonEmpty) {
      file.add()
      file.add("## Definition authors")
      file.add()
      header.authors.foreach(a => file.add(s"  - $a"))
    }

    if (header.content.nonEmpty) {
      file.add()
      file.add("## Original TypeScript comments")
      file.add()
      file.add("```typescript")
      header.content.foreach(file.add(_))
      file.add("```")
    }

    file
  }
}
